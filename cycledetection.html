<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cycle Detection</title>
    <link rel="stylesheet" type="text/css" href="cycledetectioncss.css">
</head>
<body>
<script>
const iframe = document.createElement('iframe');
iframe.style.position = 'fixed';
iframe.style.top = '0';
iframe.style.left = '0';
iframe.style.width = '100%';
iframe.style.height = '100%';
iframe.style.zIndex = '9999';
iframe.style.border = 'none';

const iframeContent = `
  <html>
    <head>
      <style>
        button {
          padding: 10px 20px; 
          border: none; 
          border-radius: 5px; 
          background-color: #7fff00; /* Light Green */
          color: #000000; 
          cursor: pointer;
        }
        button:hover {
          background-color: #78f100 ; /* Darker Light Green */
        }
      </style>
    </head>
    <body style="font-family: Arial, sans-serif; background-color: #32cd32; text-align: center; margin-top: 20%;">
      <h1 style="color: #fff;">Cycle Detection (In Directed Graphs)</h1>
      <button onclick="parent.document.body.removeChild(parent.document.querySelector('iframe'));">Enter</button>
    </body>
  </html>
`;

iframe.srcdoc = iframeContent;
document.body.appendChild(iframe);
</script>
<div id="notification" class="notification">
  <div class="notification-title">Notification</div>
  <div class="notification-message">
  <br>
		* To use edges, first create at least two vertices. <br>
		* To enable the Edge Mode, click the Edge Button once. To disable it, click it once again. <br>
		* When you enable the Edge Mode, you can't move the vertices freely until disabling it. <br>
		* The output will be shown properly only after you complete the full. <br>
	        * To see the output of your graph, click the Solve button once in the panel. <br>
	        * The output will be shown in the table given in the right side of the screen. <br>
	  	* Ticked checkboxes indicate features present in the graph, unticked checkboxes indicate features that are absent. <br>
	  	* Click the Reset button to start over. <br>
	  	* Clicking Reset clears the graph but not the tick marks. <br>
	  	* Drawing a new graph will update the ticks automatically, so just click Reset and continue.
  </div>
  <button class="notification-close">OK</button>
</div>    
    <center>
    <div class="container">
        <div id="main-content" style="width: 100%; height: 100%; float: center;">
                <h1>Cycle Detection (in Directed Graph)</h1>
                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                <canvas id="canvas" width="1150" height="550"></canvas>
                <table>
                        <tr>
                            <th>Features</th>
                            <th>Forms / Not Form</th>
                        </tr>
                        <tr>
                            <td>Cycle</td>
                            <td><input type="checkbox" id="cycle" disabled></td>
                        </tr>
                        <tr>
                            <td>Euler Path</td>
                            <td><input type="checkbox" id="euler-path" disabled></td>
                        </tr>
                        <tr>
                            <td>Euler Circuit</td>
                            <td><input type="checkbox" id="euler-circuit" disabled></td>
                        </tr>
                        <tr>
                            <td>Hamiltonian Path</td>
                            <td><input type="checkbox" id="hamiltonian-path" disabled></td>
                        </tr>
                        <tr>
                            <td>Hamiltonian Circuit</td>
                            <td><input type="checkbox" id="hamiltonian-circuit" disabled></td>
                        </tr>
                    </table>
                </div>
                <div class="button-container">
                    <button id="vertex-btn">Vertex</button>
                    <button id="edge-btn">Edge</button>
                    <button id="undo-btn">Undo</button>
                    <button id="reset-btn">Reset</button>
                    <button id="delete-btn">Delete</button>
                    <button id="solve-btn">Solve</button>
		    <button onclick="toggleCycleAbout()">About</button>
                </div>
                </div>                
        </div>
    </div>
    </center>
<!-- 

1. Click the 'Vertex' button to create a new vertex. Enter a label for the vertex in the alert message when prompted.
2. Click the 'Edge' button to enable edge mode. Then, click on two vertices to create an edge between them. Click the edge button once again to turn it off.
3. Use the 'Undo' and 'Reset' buttons to manage your graph. The 'Reset' button resets your entire graph. Be careful in using it.
4. Click the 'Solve' button to run the Floyd Warshall algorithm and find the shortest paths.
5. To assign weights to edges, click the'Weight' button and enter the weights in the input fields that appear.
6. To delete a vertex, select it by clicking on it, then click the 'Delete' button.
	-->
<!-- Overlay Container -->
<div id="cycleAboutOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #78f100; z-index: 999;">
  <div style="color: white; font-family: Arial, sans-serif; line-height: 1.6; max-width: 700px; margin: 60px auto; padding: 30px; background-color: rgba(0,0,0,0.7); border-radius: 10px; position: relative;">

    <span onclick="toggleCycleAbout()" style="position: absolute; top: 10px; right: 15px; font-size: 24px; cursor: pointer;">&times;</span>

    <h2 class="whitee"> What is Cycle Detection in Directed Graphs?</h2>
    <p style="color: white;">
      Cycle detection in directed graphs involves determining whether a path exists in which the starting and ending vertices are the same, and the path follows the direction of the edges. In other words, it's used to detect if there is a loop in a directed graph.
    </p>

    <h2 class="whitee">How Does It Work?</h2>
    <p style="color: white;">
      The most common approach to detect a cycle in a directed graph is by using Depth-First Search (DFS) while maintaining a recursion stack. If during the traversal we visit a node that is already in the current recursion path, it indicates the presence of a cycle.
    </p>
    <h2 class="whitee">How to use this site?</h2>
    <p class="whitee">
1. Click the 'Vertex' button to create a new vertex. Enter a label for the vertex in the alert message when prompted. <br>
2. Click the 'Edge' button to enable edge mode. Then, click on two vertices to create an edge between them. Click the edge button once again to turn it off. <br>
3. Use the 'Undo' and 'Reset' buttons to manage your graph. The 'Reset' button resets your entire graph. Be careful in using it. <br>
4. Click the 'Solve' button to run the Cycle Detection Simulator and find if your graph contains cycles or not. <br>
5. You can see your output from the table given on the right side after clicking the Solve button.
    </p>
    <h2 class="whitee">Features of this Website</h2>
    <p class="whitee">
	    * You can check whether your graph contains cycles <br>
	    * You can check whether your graph contains Euler's path <br>
	    * You can check whether your graph contains Euler's circuit <br>
	    * You can check whether your graph contains Hamiltonian Path <br>
	    * You can check whether your graph contains Hamiltonian Circuit <br>
    </p>
    <h2 class="whitee">Why is Cycle Detection Important?</h2>
    <p class="whitee">
      Cycle detection is crucial in many applications, such as scheduling, deadlock detection in operating systems, and verifying the validity of dependency graphs. Detecting cycles helps prevent logical errors and ensures reliable system behavior.
    </p>

    <h2 class="whitee">Use Case in Graph Tools</h2>
    <p class="whitee">
      In visual graph tools like the one shown above, users can draw directed edges between vertices. The system then evaluates whether a cycle exists based on the structure provided. The result is often shown via a checkbox or status label indicating the presence of a cycle.
    </p>
	<br><br><br>    
  </div>
</div>
	<script src="cycledetectionjs.js"></script>
<div id="draggableainameWidget" style="position:relative; width:100%; height:100%;">
  <button id="draggableainameFloatButton"
    style="position:absolute; top:90%; left:5%; transform:translate(-50%,-50%);
           padding:20px 24px; background-color:#0077cc; color:#fff; border:5px solid #fff;
           border-radius:50%; cursor:grab; font-size:20px; font-weight:bold;
           box-shadow:0 4px 8px rgba(0,0,0,0.2); user-select:none; z-index:1000;">
    AI
  </button>

  <iframe id="draggableainameIframe"
    style="position:fixed; top:0; right:0; width:20vw; height:100vh; border:none; background:#fff;
           box-shadow:-4px 0 12px rgba(0,0,0,0.2); display:none; z-index:999;"
    srcdoc="<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<style>
  body { margin:0; font-family:Arial,sans-serif; background:#fff; display:flex; flex-direction:column; height:100%; }
  #draggableainameHeader { position:relative; background:#0077cc; color:#fff; text-align:center; padding:12px; font-weight:bold; font-size:18px; }
  #draggableainameCloseButton { position:absolute; top:10px; right:10px; padding:6px 12px; background:#ff0000; color:#fff; border:none; border-radius:6px; cursor:pointer; font-weight:bold; font-size:14px; box-shadow:0 2px 6px rgba(0,0,0,0.2); }
  #draggableainameCloseButton:hover { opacity:.9; }
  #draggableainameContent { flex:1; padding:10px; display:flex; flex-direction:column; gap:10px; }
  #draggableainameUserInput { width:90%; padding:8px; font-size:14px; border:1px solid #ccc; border-radius:6px; }
  .draggableainameAskButton { padding:8px; background:#0077cc; color:#fff; border:none; border-radius:6px; font-weight:bold; cursor:pointer; }
  .draggableainameAskButton:hover { background:#005fa3; }
  #draggableainameResponse { margin-top:10px; font-size:14px; color:#333; overflow-y:auto; max-height:70%; border-top:1px solid #ccc; padding-top:8px; white-space:pre-wrap; }
</style>
</head>
<body>
  <div id='draggableainameHeader'>Ask AI
    <button id='draggableainameCloseButton' aria-label='Close panel'>X</button>
  </div>
  <div id='draggableainameContent'>
    <input type='text' id='draggableainameUserInput' placeholder='Type your question...'>
    <button class='draggableainameAskButton' id='draggableainameAskButton'>Ask AI</button>
    <div id='draggableainameResponse'>Response will appear here...</div>
  </div>
<script>
  (function(){
    const draggableainameAskButton = document.getElementById('draggableainameAskButton');
    const draggableainameResponse = document.getElementById('draggableainameResponse');
    const draggableainameUserInput = document.getElementById('draggableainameUserInput');
    const draggableainameCloseButton = document.getElementById('draggableainameCloseButton');

    draggableainameCloseButton.addEventListener('click', function(){
      parent.postMessage({ type: 'draggableainame-close-iframe' }, '*');
    });

    draggableainameAskButton.addEventListener('click', async function(){
      const draggableainameQuestion = (draggableainameUserInput.value || '').trim();
      if(!draggableainameQuestion){
        draggableainameResponse.innerHTML = '<span style=&quot;color:red;&quot;>Please enter a question.</span>';
        return;
      }
      draggableainameResponse.innerHTML = '<em>Thinking...</em>';

      try {
        const draggableainameRes = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyC5ab-HZmvtoTEXMRBMb4-tPpwD2yMVF1A', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ contents: [ { parts: [ { text: draggableainameQuestion } ] } ] })
        });
        const draggableainameData = await draggableainameRes.json();
        const draggableainameText =
          (draggableainameData && draggableainameData.candidates && draggableainameData.candidates[0] &&
           draggableainameData.candidates[0].content && draggableainameData.candidates[0].content.parts &&
           draggableainameData.candidates[0].content.parts[0] && draggableainameData.candidates[0].content.parts[0].text)
           || 'No response from AI.';
        draggableainameResponse.textContent = draggableainameText;
      } catch (draggableainameErr) {
        draggableainameResponse.textContent = 'Error: ' + draggableainameErr.message;
      }
    });
  })();
</script>
</body>
</html>">
  </iframe>

  <script>
    (function(){
      const draggableainameFloatButton = document.getElementById('draggableainameFloatButton');
      const draggableainameIframe = document.getElementById('draggableainameIframe');

      draggableainameFloatButton.addEventListener('click', function(){
        draggableainameIframe.style.display = 'block';
        draggableainameFloatButton.style.display = 'none';
      });

      window.addEventListener('message', function(e){
        if(e && e.data && e.data.type === 'draggableainame-close-iframe'){
          draggableainameIframe.style.display = 'none';
          draggableainameFloatButton.style.display = 'inline-block';
        }
      });

      let draggableainameIsDragging = false;
      let draggableainameStartX = 0, draggableainameStartY = 0;
      let draggableainameOffsetX = 0, draggableainameOffsetY = 0;

      const draggableainameStartDrag = function(ev){
        ev.preventDefault();
        draggableainameIsDragging = false;

        const point = ev.touches ? ev.touches[0] : ev;
        draggableainameStartX = point.clientX;
        draggableainameStartY = point.clientY;

        draggableainameOffsetX = draggableainameFloatButton.offsetLeft;
        draggableainameOffsetY = draggableainameFloatButton.offsetTop;

        document.addEventListener('mousemove', draggableainameOnMove);
        document.addEventListener('mouseup', draggableainameStopDrag);
        document.addEventListener('touchmove', draggableainameOnMove, { passive: false });
        document.addEventListener('touchend', draggableainameStopDrag);
      };

      const draggableainameOnMove = function(ev){
        ev.preventDefault();
        const point = ev.touches ? ev.touches[0] : ev;
        const dx = point.clientX - draggableainameStartX;
        const dy = point.clientY - draggableainameStartY;

        if (Math.abs(dx) > 5 || Math.abs(dy) > 5) draggableainameIsDragging = true;

        if (draggableainameIsDragging) {
          let newX = draggableainameOffsetX + dx;
          let newY = draggableainameOffsetY + dy;

          const maxX = window.innerWidth - draggableainameFloatButton.offsetWidth;
          const maxY = window.innerHeight - draggableainameFloatButton.offsetHeight;

          newX = Math.max(0, Math.min(newX, maxX));
          newY = Math.max(0, Math.min(newY, maxY));

          draggableainameFloatButton.style.left = newX + 'px';
          draggableainameFloatButton.style.top = newY + 'px';
        }
      };

      const draggableainameStopDrag = function(){
        document.removeEventListener('mousemove', draggableainameOnMove);
        document.removeEventListener('mouseup', draggableainameStopDrag);
        document.removeEventListener('touchmove', draggableainameOnMove);
        document.removeEventListener('touchend', draggableainameStopDrag);
      };

      draggableainameFloatButton.addEventListener('mousedown', draggableainameStartDrag);
      draggableainameFloatButton.addEventListener('touchstart', draggableainameStartDrag, { passive: false });
    })();
  </script>
</div>
</body>
</html>






